

## 正则表达式1

### re.match

- re.match尝试从字符串的起始位置匹配一个模式（匹配一次），如果不是起始位置匹配成功的话，match()就返回none。 
```
re.match(pattern, string, flags=0)

```

|参数|描述|
|--|--|
|pattern|匹配的正则表达式|
|string|要匹配的字符串|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|


```
import re
print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配

# 执行结果
(0, 3)
None
```
- re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None。



### re.search
- re.search 扫描整个字符串并返回第一个成功的匹配（匹配一次）。

```
re.search(pattern, string, flags=0)
```
|参数|描述|
|--|--|
|pattern|匹配的正则表达式|
|string|要匹配的字符串|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等|

- 匹配整个字符串，直到找到一个匹配，匹配成功re.search方法返回一个匹配的对象，否则返回None。




- 返回搜索到的第一个内容及其位置(最好加上r)
```
re.search(r'aaa','abaaabb')

# 执行结果
<re.Match object; span=(2, 5), match='aaa'>
```

- 如果搜索不到，则返回None
```
re.search(r'bbc', 'abaaabb')

# 执行结果
None
```

- 通配符 .  匹配除了\\外的任意字符
```
re.search(r'.','aaddd')

# 执行结果
<re.Match object; span=(0, 1), match='a'>
```

- 匹配d开头的任意字符
```
re.search(r'd.','aaddd')

# 执行结果
<re.Match object; span=(2, 4), match='dd'>
```

- 匹配.本身
```
re.search(r'\.','aadd.d')

# 执行结果
<re.Match object; span=(4, 5), match='.'>
```

- 匹配第一个出现的数字
```
re.search(r'\d','aa3d2dd')

# 执行结果
<re.Match object; span=(2, 3), match='3'>
```

- 匹配长度为3的数字
```
re.search(r'\d\d\d','aa32d2d444d')

# 执行结果
<re.Match object; span=(7, 10), match='444'>
```

- 匹配一个ip地址类型的数字（存在问题，如果是192.168.1.1，则匹配不到)
```
re.search(r'\d\d\d\.\d\d\d\.\d\d\d\.\d\d\d','ddd192.168.101.111')

# 执行结果
<re.Match object; span=(3, 18), match='192.168.101.111'>
```

- 中括号中任意一个匹配成功，则代表匹配成功(区分大小写)，如果不区分大小写，需加参数re.I
```
re.search(r'[ccadq]','eeeqaa3d2d444d')

# 执行结果
<re.Match object; span=(3, 4), match='q'>

print(re.search(r'[ccadQ]','eeeqaa3d2d444d',re.I))

# 执行结果
<re.Match object; span=(3, 4), match='q'>
```

- 指定范围(字母）
```
re.search(r'[c-z]','223aa3d2d444d')

# 执行结果
<re.Match object; span=(6, 7), match='d'>
```

- 指定范围(数字）
```
re.search(r'[0-9]','aa3d2d444d')

# 执行结果
<re.Match object; span=(2, 3), match='3'>
```

- 大括号限定某个字符的重复次数 （ddd4)
```
re.search(r'd{3}4','aa3d2ddd444dddd4')

# 执行结果
<re.Match object; span=(5, 9), match='ddd4'>
```

- 大括号限定某个字符的重复次数范围(ddd4,dddd4,ddddd4)
```
re.search(r'd{3,5}4','aa3d2dd444dddd4')

# 执行结果
<re.Match object; span=(10, 15), match='dddd4'>
```

- 大括号限定某个字符的重复次数范围(0表示不含此字符)(4,d4,44d)
```
re.search(r'd{0,2}4','aa3d2d4dd444dddd4')

# 执行结果
<re.Match object; span=(5, 7), match='d4'>
```

- 数字的匹配（匹配0-255）
> 因为匹配的是字符串，所有想要匹配188，只能一位一位的匹配不能直接[0-188]，中括号多余数字的范围只有0-9
```
re.search(r'[01]\d\d|2[0-4]\d|25[0-5]','188')

# 执行结果
<re.Match object; span=(0, 3), match='188'>
```

- 匹配ip地址
> 小括号表示分组 
> 获获取0到255：
```
re.search(r'[01]{0,1}\d{0,1}\d{0,1}|2{0,1}[0-4]{0,1}\d{0,1}|2{0,1}5{0,1}\d{0,1}','2')
```

```
re.search(r'(([01]{0,1}\d{0,1}\d{0,1}|2{0,1}[0-4]{0,1}\d{0,1}|2{0,1}5{0,1}\d{0,1})\.){3}([01]{0,1}\d{0,1}\d{0,1}|2{0,1}[0-4]{0,1}\d{0,1}|2{0,1}5{0,1}\d{0,1})','192.255.1.255.')

# 执行结果
<re.Match object; span=(0, 12), match='192.255.1.25'>

```



## 正则表达式2



### 检索和替换

- Python 的 re 模块提供了re.sub用于替换字符串中的匹配项

```
re.sub(pattern, repl, string, count=0, flags=0)
```

|参数|描述|
|--|--|
|pattern|正则中的模式字符串。|
|repl|替换的字符串，也可为一个函数。|
|string|要被查找替换的原始字符串。|
|count|模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。|

- repl是字符串
```
import re
a = 'abcdeeefffg'
aa =re.sub(r'e','h',a) # 替换a中的e为h，替换所有
bb =re.sub(r'e','h',a,1) # 替换a中的e为h，替换一次
print(aa)
print(bb)

# 执行结果
abcdhhhfffg
abcdheefffg
```

- repl是函数
```
待补充
```

### re.compile 函数

- compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用

```
re.compile(pattern[, flags])
```

|参数|描述|
|--|--|
|pattern|一个字符串形式的正则表达式|
|flags|可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：|

|参数|描述|
|--|--|
|re.I|忽略大小写|
|re.L|表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境|
|re.M|多行模式
|re.S|即为 . 并且包括换行符在内的任意字符（. 不包括换行符）|
|re.U|表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库|
|re.X|为了增加可读性，忽略空格和 # 后面的注释|


```
import re
a = 'abcd2ea1eAe3fffg'
pattern = re.compile(r'\d+')
aa =pattern.search(a)
print(aa)

#执行结果
<re.Match object; span=(4, 5), match='2'>
```







### re.findall 函数

- 在字符串中找到正则表达式所匹配的所有子串（匹配所有），并返回一个列表，如果没有找到匹配的，则返回空列表。

```
findall(string[, pos[, endpos]])
```
|参数|描述|
|--|--|
|string|待匹配的字符串。|
|pos|可选参数，指定字符串的起始位置，默认为 0。|
|endpos|可选参数，指定字符串的结束位置，默认为字符串的长度。|


```
import re
a = 'abcdeaeAefffg'
aa =re.findall(r'a',a)
print(aa)

# 执行结果
['a', 'a']
```

### re.split 函数

- split 方法按照能够匹配的子串将字符串分割后返回列表

```
re.split(pattern, string[, maxsplit=0, flags=0])
```

|参数|描述|
|--|--|
|pattern|匹配的正则表达式|
|string|要匹配的字符串。|
|maxsplit|分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。|
|flags|标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。|

```
import re
a = 'abcdeaeAefffg'
aa =re.split(r'a',a)
print(aa)

# 执行结果
['', 'bcde', 'eAefffg']
```












### 正则表达式对象对应的方法
|方法|描述|
|--|--|
|group()|返回被 RE 匹配的字符串|
|start()|返回匹配开始的位置|
|end()|返回匹配结束的位置|
|span()| 返回一个元组包含匹配 (开始,结束) 的位置，相当于(start(),end())|
	
```
a = 'abcdeaeefffg'
aa =re.search(r'ee',a)
print(aa)
print('------------------------')
print(aa.group())
print(aa.start())
print(aa.end())
print(aa.span())

# 执行结果
<re.Match object; span=(6, 8), match='ee'>
------------------------
ee
6
8
(6, 8)
```



## 正则表达式模式

- 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符。


### 实例
##### ^	：	匹配字符串的开头
```

```

##### $	：	匹配字符串的末尾。
```

```

##### .	：	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
```

```

##### [...]	：	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
```

```

##### [^...]	：	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
```

```

##### re*	：	匹配0个或多个的表达式。
```

```

##### re+	：	匹配1个或多个的表达式。
```

```

##### re?	：	匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
```

```

##### re{n}	：	精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。
```

```

##### re{n,}	：	匹配 n个或大于n个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。
```

```

##### re{n, m}	：	匹配 n 到 m 次（包含n和m）由前面的正则表达式定义的片段，贪婪方式
```

```

##### a| b	：	匹配a或b
```

```

##### (re)	：	对正则表达式分组并记住匹配的文本
```

```

##### (?imx)	：	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
```

```

##### (?-imx)	：	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
```

```

##### (?: re)	：	类似 (...), 但是不表示一个组
```

```

##### (?imx: re)	：	在括号中使用i, m, 或 x 可选标志
```

```

##### (?-imx: re)	：	在括号中不使用i, m, 或 x 可选标志
```

```

##### (?#...)	：	注释.
```

```

##### (?= re)	：	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
```

```

##### (?! re)	：	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
```

```

##### (?> re)	：	匹配的独立模式，省去回溯。
```

```

##### \w	：	匹配字母数字及下划线
```

```

##### \W	：	匹配非字母数字及下划线
```

```

##### \s	：	匹配任意空白字符，等价于 [\t\n\r\f].
```

```

##### \S	：	匹配任意非空字符
```

```

##### \d	：	匹配任意数字，等价于 [0-9].
```

```

##### \D	：	匹配任意非数字
```

```

##### \A	：	匹配字符串开始
```

```

##### \Z	：	匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
```

```

##### \z	：	匹配字符串结束
```

```

##### \G	：	匹配最后匹配完成的位置。
```

```

##### \b	：	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
```

```

##### \B	：	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
```

```

##### \n, \t, 等.	：	匹配一个换行符。匹配一个制表符。等
```

```

##### \1...\9	：	匹配第n个分组的内容。
```

```

##### \10	：	匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式
```


```


### 查询

|	模式	|	描述	|
| -- | -- |
|	^	|	匹配字符串的开头	|
|	$	|	匹配字符串的末尾。	|
|	.	|	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。	|
|	[...]	|	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'	|
|	[^...]	|	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。	|
|	re*	|	匹配0个或多个的表达式。	|
|	re+	|	匹配1个或多个的表达式。	|
|	re?	|	匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式	|
|	re{ n}	|	精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。	|
|	re{ n,}	|	匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。	|
|	re{ n, m}	|	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式	|
|	a| b	|	匹配a或b	|
|	(re)	|	对正则表达式分组并记住匹配的文本	|
|	(?imx)	|	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。	|
|	(?-imx)	|	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。	|
|	(?: re)	|	类似 (...), 但是不表示一个组	|
|	(?imx: re)	|	在括号中使用i, m, 或 x 可选标志	|
|	(?-imx: re)	|	在括号中不使用i, m, 或 x 可选标志	|
|	(?#...)	|	注释.	|
|	(?= re)	|	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。	|
|	(?! re)	|	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功	|
|	(?> re)	|	匹配的独立模式，省去回溯。	|
|	\w	|	匹配字母数字及下划线	|
|	\W	|	匹配非字母数字及下划线	|
|	\s	|	匹配任意空白字符，等价于 [\t\n\r\f].	|
|	\S	|	匹配任意非空字符	|
|	\d	|	匹配任意数字，等价于 [0-9].	|
|	\D	|	匹配任意非数字	|
|	\A	|	匹配字符串开始	|
|	\Z	|	匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。	|
|	\z	|	匹配字符串结束	|
|	\G	|	匹配最后匹配完成的位置。	|
|	\b	|	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。	|
|	\B	|	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。	|
|	\n, \t, 等.	|	匹配一个换行符。匹配一个制表符。等	|
|	\1...\9	|	匹配第n个分组的内容。	|
|	\10	|	匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。	|












## 正则表达式实例

### 字符匹配
|实例|描述|
|--|--|
|python|匹配 "python".|

### 字符类
|实例|描述|
|--|--|
|[Pp]ython|匹配 "Python" 或 "python"|
rub[ye]|匹配 "ruby" 或 "rube"|
[aeiou]|匹配中括号内的任意一个字母|
[0-9]|匹配任何数字。类似于 [0123456789]|
[a-z]|匹配任何小写字母|
[A-Z]|匹配任何大写字母|
[a-zA-Z0-9]|匹配任何字母及数字|
[^aeiou]|除了aeiou字母以外的所有字符|
[^0-9]|匹配除了数字外的字符|


### 特殊字符类

|实例|描述|
|--|--|
|.|匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。|
\d|匹配一个数字字符。等价于 [0-9]。|
\D|匹配一个非数字字符。等价于 [^0-9]。|
\s|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。|
\S|匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。|
\w|匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。|
\W|匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。|

